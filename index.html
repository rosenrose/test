<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>frames</title>
    <script src="coi-serviceworker.js"></script>
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.9.8/dist/ffmpeg.min.js" crossorigin></script>
    <link rel="preload" href="ffmpeg-core.js" />
    <link rel="preload" href="ffmpeg-core.wasm" />
    <link rel="preload" href="ffmpeg-core.worker.js" />
    <style>
      .item {
        display: inline-block;
        max-width: 32.8%;
        margin: 0.2em;
      }
      .item img {
        width: 100%;
      }
      .item figcaption {
        margin: 0;
      }

      @media (max-width: 768px) {
        .item {
          max-width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div id="input">
      <input type="text" name="url" />
      <input type="file" name="animFile" accept=".mp4,.gif,.webm" />
      <button type="submit" id="btn1">upload</button>
      <button type="button" id="btn2">webp</button>
    </div>
    <p id="progressShow"></p>
    <div id="frames"></div>
    <img src="" id="webp" />
    <template id="itemTemplate">
      <figure class="item">
        <img src="" />
        <figcaption></figcaption>
      </figure>
    </template>
    <script type="text/javascript">
      let frames = document.querySelector("#frames");
      let progressShow = document.querySelector("#progressShow");
      const { createFFmpeg, fetchFile } = FFmpeg;
      // const ffmpeg = createFFmpeg({ log: true, corePath: "./ffmpeg-core.js" });
      const ffmpeg = createFFmpeg({ log: true });

      ffmpeg.setLogger((log) => {
        //log.type: info, fferr, ffout
        console.log(log);
        // if (log.type == "fferr") {
        progressShow.textContent = log.message;
        // }
      });
      (async () => {
        await ffmpeg.load();
      })();

      ffmpeg.setProgress((progress) => {
        console.log(progress);
      });

      //교체됨
      ffmpeg.setLogger((log) => {
        console.log(log.type, log.message.split(" "));
      });

      document.querySelector("#btn1").addEventListener("click", async () => {
        frames.querySelectorAll("figure").forEach((figure) => {
          URL.revokeObjectURL(figure.querySelector("img").src);
          ffmpeg.FS("unlink", `${figure.querySelector("figcaption").textContent}.jpg`);
        });
        frames.replaceChildren();

        let name = "input";
        let input;
        let file = document.querySelector("input[type='text']").value;

        if (file) {
          input = new Uint8Array(
            await (
              await fetch("https://d27lgm9mrrpaxd.cloudfront.net/proxy.php", {
                method: "post",
                headers: { "Content-Type": "application/x-www-form-urlencoded" },
                body: `url=${file}`,
              })
            ).arrayBuffer()
          );
        } else {
          input = await fetchFile(document.querySelector("input[type='file']").files[0]);
        }

        ffmpeg.FS("writeFile", name, input);
        await ffmpeg.run("-i", name, "%5d.jpg");

        let i = 1;
        while (true) {
          let output = i.toString().padStart(5, "0");

          try {
            data = ffmpeg.FS("readFile", `${output}.jpg`);
          } catch (err) {
            break;
          }

          let template = document.querySelector("#itemTemplate").content.cloneNode(true);
          let img = template.querySelector("img");
          let caption = template.querySelector("figcaption");

          img.src = URL.createObjectURL(new Blob([data.buffer], { type: "image/jpeg" }));
          caption.textContent = output;
          frames.append(template.firstElementChild);
          i += 1;
        }

        progressShow.textContent = "";
      });

      document.querySelector("#btn2").addEventListener("click", async () => {
        let time = Date.now().toString();
        let dir = time + "가 나 다";
        let outputName = "라마 a.webp";

        ffmpeg.FS("mkdir", encodeURIComponent(dir));
        let downloadPromises = [];
        let rand = getRandomInt(100, 1000);
        for (let i = 0; i < 18; i++) {
          let name = `${(rand + i).toString().padStart(5, "0")}.jpg`;

          downloadPromises.push(
            new Promise((resolve) => {
              fetchFile(`https://d2wwh0934dzo2k.cloudfront.net/ghibli/07 붉은 돼지 (1992)/${name}`).then((file) => {
                ffmpeg.FS("writeFile", `${encodeURIComponent(dir)}/${encodeURIComponent(`마 ${name}`)}`, file);
                resolve();
              });
            })
          );
          console.log(name);
        }

        await Promise.all(downloadPromises);
        await ffmpeg.run(
          "-framerate",
          "12",
          "-pattern_type",
          "glob",
          "-i",
          `${encodeURIComponent(dir)}/*.jpg`,
          "-vf",
          "scale=720:-1",
          "-loop",
          "0",
          `${encodeURIComponent(dir)}/${encodeURIComponent(outputName)}`
        );
        let webp = ffmpeg.FS("readFile", `${encodeURIComponent(dir)}/${encodeURIComponent(outputName)}`);
        document.querySelector("#webp").src = URL.createObjectURL(new Blob([webp.buffer], { type: "image/webp" }));
      });
      // data = ffmpeg.FS('readFile', 'output.mp4');
      // video = document.createElement("video");
      // video.controls = true;
      // video.autoplay = false;
      // video.src = URL.createObjectURL(new Blob([data.buffer], { type: 'video/mp4' }));
      // document.body.append(video);
      function getRandomInt(minInclude, maxExclude) {
        return Math.floor(Math.random() * (maxExclude - minInclude)) + minInclude;
      }
    </script>
  </body>
</html>
